import { BigNumberish, BigNumber } from "ethers";
import {
  IAccount__factory,
  EntryPoint,
  IAggregatedAccount__factory,
  IAggregator__factory,
  IPaymaster__factory,
} from "types/lib/executor/contracts";
import { Interface, hexZeroPad, keccak256 } from "ethers/lib/utils";
import { UserOperationStruct } from "types/lib/executor/contracts/EntryPoint";
import * as RpcErrorCodes from "types/lib/api/errors/rpc-error-codes";
import { EntryPoint__factory } from "types/src/executor/contracts";
import { BundlerCollectorReturn } from "types/lib/executor";
import { StakeInfo, StorageMap, UserOpValidationResult } from "../interfaces";
import { requireCond, toBytes32 } from "./utils";

interface CallEntry {
  to: string;
  from: string;
  type: string; // call opcode
  method: string; // parsed method, or signash if unparsed
  revert?: any; // parsed output from REVERT
  return?: any; // parsed method output.
  value?: BigNumberish;
}

/**
 * parse all call operation in the trace.
 * notes:
 * - entries are ordered by the return (so nested call appears before its outer call
 * - last entry is top-level return from "simulateValidation". it as ret and rettype, but no type or address
 * @param tracerResults
 */
function parseCallStack(tracerResults: BundlerCollectorReturn): CallEntry[] {
  const abi = Object.values(
    [
      ...EntryPoint__factory.abi,
      ...IAccount__factory.abi,
      ...IAggregatedAccount__factory.abi,
      ...IAggregator__factory.abi,
      ...IPaymaster__factory.abi,
    ].reduce((set, entry: any) => {
      const key = `${entry.name}(${entry?.inputs
        ?.map((i: any) => i.type)
        .join(",")})`;
      return {
        ...set,
        [key]: entry,
      };
    }, {})
  ) as any;

  const xfaces = new Interface(abi);

  function callCatch<T, T1>(x: () => T, def: T1): T | T1 {
    try {
      return x();
    } catch {
      return def;
    }
  }

  const out: CallEntry[] = [];
  const stack: any[] = [];
  tracerResults.calls
    .filter((x) => !x.type.startsWith("depth"))
    .forEach((c) => {
      if (c.type.match(/REVERT|RETURN/) != null) {
        const top = stack.splice(-1)[0] ?? {
          type: "top",
          method: "validateUserOp",
        };
        const returnData: string = (c as any).data;
        if (top.type.match(/CREATE/) != null) {
          out.push({
            to: top.to,
            from: top.from,
            type: top.type,
            method: "",
            return: `len=${returnData.length}`,
          });
        } else {
          const method = callCatch(
            () => xfaces.getFunction(top.method),
            top.method
          );
          if (c.type === "REVERT") {
            const parsedError = callCatch(
              () => xfaces.parseError(returnData),
              returnData
            );
            out.push({
              to: top.to,
              from: top.from,
              type: top.type,
              method: method.name,
              value: top.value,
              revert: parsedError,
            });
          } else {
            const ret = callCatch(
              () => xfaces.decodeFunctionResult(method, returnData),
              returnData
            );
            out.push({
              to: top.to,
              from: top.from,
              type: top.type,
              method: method.name ?? method,
              return: ret,
            });
          }
        }
      } else {
        stack.push(c);
      }
    });

  // TODO: verify that stack is empty at the end.

  return out;
}

/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * removed rule: keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak array of buffers that were given to keccak in the transaction
 */
function parseEntitySlots(
  stakeInfoEntities: { [addr: string]: StakeInfo | undefined },
  keccak: string[]
): { [addr: string]: Set<string> } {
  // for each entity (sender, factory, paymaster), hold the valid slot addresses
  // valid: the slot was generated by keccak(entity || ...)
  const entitySlots: { [addr: string]: Set<string> } = {};

  keccak.forEach((k) => {
    Object.values(stakeInfoEntities).forEach((info) => {
      const addr = info?.addr?.toLowerCase();
      if (addr == null) return;
      const addrPadded = toBytes32(addr);
      if (entitySlots[addr] == null) {
        entitySlots[addr] = new Set<string>();
      }

      const currentEntitySlots = entitySlots[addr];

      // valid slot: the slot was generated by keccak(entityAddr || ...)
      if (k.startsWith(addrPadded)) {
        // console.log('added mapping (balance) slot', value)
        currentEntitySlots.add(keccak256(k));
      }
      // disabled 2nd rule: .. or by keccak( ... || OWN) where OWN is previous allowed slot
      // if (k.length === 130 && currentEntitySlots.has(k.slice(-64))) {
      //   // console.log('added double-mapping (allowance) slot', value)
      //   currentEntitySlots.add(value)
      // }
    });
  });

  return entitySlots;
}

// method-signature for calls from entryPoint
const callsFromEntryPointMethodSigs: { [key: string]: string } = {
  factory: SenderCreator__factory.createInterface().getSighash("createSender"),
  account: IAccount__factory.createInterface().getSighash("validateUserOp"),
  paymaster: IPaymaster__factory.createInterface().getSighash(
    "validatePaymasterUserOp"
  ),
};

/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param validationResult output from simulateValidation
 * @param entryPoint the entryPoint that hosted the "simulatedValidation" traced call.
 * @return list of contract addresses referenced by this UserOp
 */
export function parseScannerResult(
  userOp: UserOperationStruct,
  tracerResults: BundlerCollectorReturn,
  validationResult: UserOpValidationResult,
  entryPoint: EntryPoint
): [string[], StorageMap] {
  // todo: block access to no-code addresses (might need update to tracer)

  const entryPointAddress = entryPoint.address.toLowerCase();

  const bannedOpCodes = new Set([
    "GASPRICE",
    "GASLIMIT",
    "DIFFICULTY",
    "TIMESTAMP",
    "BASEFEE",
    "BLOCKHASH",
    "NUMBER",
    "SELFBALANCE",
    "BALANCE",
    "ORIGIN",
    "GAS",
    "CREATE",
    "COINBASE",
    "SELFDESTRUCT",
    "RANDOM",
    "PREVRANDAO",
  ]);

  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  if (Object.values(tracerResults.callsFromEntryPoint).length < 1) {
    throw new Error("Unexpected traceCall result: no calls from entrypoint.");
  }
  const callStack = parseCallStack(tracerResults);

  const callInfoEntryPoint = callStack.find(
    (call) =>
      call.to === entryPointAddress &&
      call.from !== entryPointAddress &&
      call.method !== "0x" &&
      call.method !== "depositTo"
  );

  requireCond(
    callInfoEntryPoint == null,
    `illegal call into EntryPoint during validation ${callInfoEntryPoint?.method}`,
    RpcErrorCodes.INVALID_OPCODE
  );

  requireCond(
    callStack.find(
      (call) =>
        call.to !== entryPointAddress &&
        BigNumber.from(call.value ?? 0) !== BigNumber.from(0)
    ) != null,
    "May not may CALL with value",
    RpcErrorCodes.INVALID_OPCODE
  );

  const sender = userOp.sender.toLowerCase();
  // stake info per "number" level (factory, sender, paymaster)
  // we only use stake info if we notice a memory reference that require stake
  const stakeInfoEntities = {
    factory: validationResult.factoryInfo,
    account: validationResult.senderInfo,
    paymaster: validationResult.paymasterInfo,
  };

  const entitySlots: { [addr: string]: Set<string> } = parseEntitySlots(
    stakeInfoEntities,
    tracerResults.keccak
  );

  Object.entries(stakeInfoEntities).forEach(([entityTitle, entStakes]) => {
    const entityAddr = (entStakes?.addr ?? "").toLowerCase();
    const currentNumLevel = tracerResults.callsFromEntryPoint.find(
      (info) =>
        info.topLevelMethodSig === callsFromEntryPointMethodSigs[entityTitle]
    );
    if (currentNumLevel == null) {
      if (entityTitle === "account") {
        // should never happen... only factory, paymaster are optional.
        throw new Error("missing trace into validateUserOp");
      }
      return;
    }
    const opcodes = currentNumLevel.opcodes;
    const access = currentNumLevel.access;

    requireCond(
      !(currentNumLevel.oog ?? false),
      `${entityTitle} internally reverts on oog`,
      RpcErrorCodes.INVALID_OPCODE
    );
    Object.keys(opcodes).forEach((opcode) =>
      requireCond(
        !bannedOpCodes.has(opcode),
        `${entityTitle} uses banned opcode: ${opcode}`,
        RpcErrorCodes.INVALID_OPCODE
      )
    );
    if (entityTitle === "factory") {
      requireCond(
        (opcodes.CREATE2 ?? 0) <= 1,
        `${entityTitle} with too many CREATE2`,
        RpcErrorCodes.INVALID_OPCODE
      );
    } else {
      requireCond(
        opcodes.CREATE2 == null,
        `${entityTitle} uses banned opcode: CREATE2`,
        RpcErrorCodes.INVALID_OPCODE
      );
    }

    Object.entries(access).forEach(([addr, { reads, writes }]) => {
      // testing read/write access on contract "addr"
      if (addr === sender) {
        // allowed to access sender's storage
        return;
      }
      if (addr === entryPointAddress) {
        // ignore storage access on entryPoint (balance/deposit of entities.
        // we block them on method calls: only allowed to deposit, never to read
        return;
      }

      // return true if the given slot is associated with the given address, given the known keccak operations:
      // @param slot the SLOAD/SSTORE slot address we're testing
      // @param addr - the address we try to check for association with
      // @param reverseKeccak - a mapping we built for keccak values that contained the address
      function associatedWith(
        slot: string,
        addr: string,
        entitySlots: { [addr: string]: Set<string> }
      ): boolean {
        const addrPadded = hexZeroPad(addr, 32).toLowerCase();
        if (slot === addrPadded) {
          return true;
        }
        const k = entitySlots[addr];
        if (k == null) {
          return false;
        }
        const slotN = BigNumber.from(slot);
        // scan all slot entries to check of the given slot is within a structure, starting at that offset.
        // assume a maximum size on a (static) structure size.
        for (const k1 of k.keys()) {
          const kn = BigNumber.from(k1);
          if (slotN.gte(kn) && slotN.lt(kn.add(128))) {
            return true;
          }
        }
        return false;
      }

      // scan all slots. find a referenced slot
      // at the end of the scan, we will check if the entity has stake, and report that slot if not.
      let requireStakeSlot: string | undefined;
      [...Object.keys(writes), ...Object.keys(reads)].forEach((slot) => {
        // slot associated with sender is allowed (e.g. token.balanceOf(sender)
        // but during initial UserOp (where there is an initCode), it is allowed only for staked entity
        if (associatedWith(slot, sender, entitySlots)) {
          if (userOp.initCode.length > 2) {
            // special case: account.validateUserOp is allowed to use assoc storage if factory is staked.
            if (
              !(entityAddr === sender && isStaked(stakeInfoEntities.factory))
            ) {
              requireStakeSlot = slot;
            }
          }
        } else if (associatedWith(slot, entityAddr, entitySlots)) {
          // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
          requireStakeSlot = slot;
        } else if (addr === entityAddr) {
          // accessing storage member of entity itself requires stake.
          requireStakeSlot = slot;
        } else {
          // accessing arbitrary storage of another contract is not allowed
          const readWrite = Object.keys(writes).includes(addr)
            ? "write to"
            : "read from";
          requireCond(
            false,
            `${entityTitle} has forbidden ${readWrite} ${nameAddr(
              addr,
              entityTitle
            )} slot ${slot}`,
            RpcErrorCodes.INVALID_OPCODE,
            { [entityTitle]: entStakes?.addr }
          );
        }
      });

      // if addr is current account/paymaster/factory, then return that title
      // otherwise, return addr as-is
      function nameAddr(addr: string, _currentEntity: string): string {
        const [title] =
          Object.entries(stakeInfoEntities).find(
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            ([title, info]) => info?.addr.toLowerCase() === addr.toLowerCase()
          ) ?? [];

        return title ?? addr;
      }

      requireCondAndStake(
        requireStakeSlot != null,
        entStakes,
        `unstaked ${entityTitle} accessed ${nameAddr(
          addr,
          entityTitle
        )} slot ${requireStakeSlot}`
      );
    });

    if (entityTitle === "paymaster") {
      const validatePaymasterUserOp = callStack.find(
        (call) =>
          call.method === "validatePaymasterUserOp" && call.to === entityAddr
      );
      const context = validatePaymasterUserOp?.return?.context;
      requireCondAndStake(
        context != null && context !== "0x",
        entStakes,
        "unstaked paymaster must not return context"
      );
    }

    // check if the given entity is staked
    function isStaked(entStake?: StakeInfo): boolean {
      return (
        entStake != null &&
        BigNumber.from(1).lte(entStake.stake) &&
        BigNumber.from(1).lte(entStake.unstakeDelaySec)
      );
    }

    // helper method: if condition is true, then entity must be staked.
    function requireCondAndStake(
      cond: boolean,
      entStake: StakeInfo | undefined,
      failureMessage: string
    ): void {
      if (!cond) {
        return;
      }
      if (entStake == null) {
        throw new Error(
          `internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(
            access
          )}`
        );
      }
      requireCond(
        isStaked(entStake),
        failureMessage,
        RpcErrorCodes.INVALID_OPCODE,
        { [entityTitle]: entStakes?.addr }
      );

      // TODO: check real minimum stake values
    }

    // the only contract we allow to access before its deployment is the "sender" itself, which gets created.
    requireCond(
      Object.keys(currentNumLevel.contractSize).find(
        (addr) => addr !== sender && currentNumLevel.contractSize[addr] <= 2
      ) == null,
      `${entityTitle} accesses un-deployed contract ${JSON.stringify(
        currentNumLevel.contractSize
      )}`,
      RpcErrorCodes.INVALID_OPCODE
    );
  });

  // return list of contract addresses by this UserOp. already known not to contain zero-sized addresses.
  const addresses = tracerResults.callsFromEntryPoint.flatMap((level) =>
    Object.keys(level.contractSize)
  );
  const storageMap: StorageMap = {};
  tracerResults.callsFromEntryPoint.forEach((level) => {
    Object.keys(level.access).forEach((addr) => {
      storageMap[addr] = storageMap[addr] ?? level.access[addr].reads;
    });
  });
  return [addresses, storageMap];
}
